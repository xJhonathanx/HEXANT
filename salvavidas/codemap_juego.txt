# CodeMap  juego
Generado: 2025-09-21 18:58:04
Carpeta base: E:\GAME\HEXANTV1\src\hexant\juego
Máx tamaño por archivo: 512 KB
Extensiones incluidas: .ts, .tsx, .js, .jsx, .mjs, .cjs, .css, .scss, .less, .html, .md, .json, .yml, .yaml, .svg, .txt, .ps1, .psm1, .sh

## Carpeta: .

--- index.ts  (2.9 KB)
  1 | import { World, Hex, Ant, AntKind } from "../tipos";
  2 | import { Cfg } from "./configuracion/predeterminados";
  3 | import { randf } from "../utilidades/matematica";
  4 | import { axialToPixelPT } from "../utilidades/hex";
  5 | 
  6 | 
  7 | /** Vecinos en axial (pointy-top) */
  8 | const DIRS: Array<[number, number]> = [
  9 |   [1, 0], [1, -1], [0, -1], [-1, 0], [-1, 1], [0, 1],
 10 | ];
 11 | 
 12 | /** Crea el mundo vacío y poblado mínimamente. */
 13 | export function crearMundoInicial(W:number, H:number): World {
 14 |   return { eggs: [], nextEggId: 1,
 15 |     ants: [], food: [], hazards: [], corpses: [], beacons: [],
 16 |     looseDecos: [], nextDecoId: 1,
 17 |     stockFood: 0, stockTotal: 0,
 18 |     hexes: [], nextHexId: 1,
 19 |     spawnCooldown: 0, nextAntId: 1, noFoodTicks: 0,
 20 |     camera: { x: 0, y: 0, scale: 1 },
 21 |     ui: { influenceFlashTicks: 0 },
 22 |     _tick: 0,
 23 |   };
 24 | }
 25 | 
 26 | /** Bootstrap: crea reina, una semilla de comida y hormigas iniciales. */
 27 | export function bootstrapWorld(w: World, cfg: Cfg, cx: number, cy: number) {
 28 |   // Garantiza reina central si no existe
 29 |   if (!w.hexes.some(h=>h.host==="queen")){
 30 |     const S = 36;
 31 |     w.hexes.push({
 32 |       id: w.nextHexId++,
 33 |       cx, cy, sidePx: S,
 34 |       host: "queen", capacity: 999, occupancy: 0,
 35 |       completed: true, aq: 0, ar: 0
 36 |     } as any);
 37 |   }
 38 |   const S = 38;
 39 | 
 40 |   // Reina
 41 |   const queenHex: Hex = {
 42 |     id: w.nextHexId++,
 43 |     cx, cy,
 44 |     sidePx: S,
 45 |     targetUnits: 0, builtUnits: 0,
 46 |     host: "queen",
 47 |     capacity: 0, occupancy: 0,
 48 |     completed: true,
 49 |     stockUnd: 0,
 50 |     eggs: undefined,
 51 |     decos: [],
 52 |     aq: 0, ar: 0, connections: 0,
 53 |   };
 54 |   w.hexes.push(queenHex);
 55 | 
 56 |   // Semilla de comida (para arrancar)
 57 |   const seed = 80;
 58 |   w.food.push({ x: cx + S * 1.2, y: cy, amount: seed, initial: seed });
 59 | 
 60 |   // Hormigas iniciales sobre la reina
 61 |   if (cfg.initialBuilder) w.ants.push(newAnt(cx, cy, "builder", w, queenHex.id));
 62 |   for (let i = 0; i < Math.max(0, cfg.initialWorkers); i++) {
 63 |     w.ants.push(newAnt(cx, cy, "worker", w, queenHex.id));
 64 |   }
 65 | }
 66 | 
 67 | export function newAnt(
 68 |   x: number, y: number, kind: AntKind, world: World, homeHexId: number | null
 69 | ): Ant {
 70 |   return {
 71 |     id: world.nextAntId++,
 72 |     kind,
 73 |     x, y,
 74 |     vx: randf(-0.3, 0.3),
 75 |     vy: randf(-0.3, 0.3),
 76 |     state: kind === "builder" ? "building" : "foraging",
 77 |     ageTicks: 0,
 78 |     homeHexId,
 79 |     hungerUnd: 0,
 80 |     starveTicks: 0,
 81 |     carryingUnits: 0,
 82 |     carryingDecoId: null,
 83 |     lastFoodPos: null,
 84 |     attackCd: 0,
 85 |     energyPct: 100,
 86 |     totalDistPx: 0,
 87 |     waitTicks: 0,
 88 |     targetHexId: null,
 89 |   };
 90 | }
 91 | 
 92 | /** Planificación vecina (stub mínimo para Lote D; se ampliará en Lote E/F) */
 93 | export function axialVecinoRandom(aq:number, ar:number){
 94 |   const d = DIRS[(Math.random()*6)|0];
 95 |   return { q: aq + d[0], r: ar + d[1] };
 96 | }
 97 | 
 98 | export function axialToPixelRel(q:number, r:number, side:number){
 99 |   return axialToPixelPT(q, r, side);
100 | }
101 | export { SistemaPlanificacion } from "./sistemas/SistemaPlanificacion";
102 | 
103 | 
104 | 

--- README.md  (0.1 KB)
  1 | # Placeholder Lote A
  2 | Esta carpeta se llenará en los lotes siguientes. Mantener nombres sencillos.


## Carpeta: configuracion

--- configuracion\predeterminados.ts  (3.3 KB)
  1 | /* ===== Influencia de la reina ===== */
  2 | export const INFLUENCE_BASE_PX    = 220;
  3 | export const INFLUENCE_PER_HEX_PX = 28;
  4 | 
  5 | /* ================= Reloj base ================= */
  6 | export const TICKS_PER_SEC = 60;
  7 | export const TICKS_PER_MIN = 60 * TICKS_PER_SEC;
  8 | 
  9 | /* ============== Metabolismo / hambre ============== */
 10 | export const CONSUME_PER_TICK = 5 / TICKS_PER_MIN;
 11 | export const STARVE_OUTSIDE  = 3 * TICKS_PER_MIN;
 12 | export const STARVE_INSIDE   = 5 * TICKS_PER_MIN;
 13 | 
 14 | /* =================== Cría (huevos) =================== */
 15 | export const HATCH_TIME    = 45 * TICKS_PER_SEC; // 45 s de incubación
 16 | export const EGGS_NEED_UND = 25;                // 100 und de comida para el lote
 17 | export const EGGS_TTL_TICKS = 5 * TICKS_PER_MIN; // 5 minutos sin alimentar  desaparecen
 18 | 
 19 | /* ================= Viajes / carga ================= */
 20 | export const CARRY_PER_TRIP = 7;
 21 | 
 22 | /* ============== Olfato / feromonas ============== */
 23 | export const SMELL_RADIUS          = 100;
 24 | export const SMELL_RADIUS_MIN      = 60;
 25 | export const SMELL_RADIUS_PER_UNIT = 1.0;
 26 | 
 27 | /* =================== Límites =================== */
 28 | export const MAX_BEACONS   = 160;
 29 | export const MAX_CORPSES   = 400;
 30 | export const HEX_STOCK_CAP = 50;
 31 | 
 32 | /* =================== TTL feromonas =================== */
 33 | export const BEACON_TTL_FOOD = 5 * TICKS_PER_SEC;
 34 | export const BEACON_TTL_HELP = 12 * TICKS_PER_SEC;
 35 | 
 36 | /* =================== Hazard =================== */
 37 | export const HAZARD_MAX_SPEED     = 0.65;
 38 | export const HAZARD_SUCK_PER_TICK = 0.9;
 39 | 
 40 | /* ============== Spawns aleatorios ============== */
 41 | export const FOOD_AUTO_MIN_SEC   = 12;
 42 | export const FOOD_AUTO_MAX_SEC   = 28;
 43 | export const HAZARD_AUTO_MIN_SEC = 12;
 44 | export const HAZARD_AUTO_MAX_SEC = 24;
 45 | 
 46 | /* ============== Construcción (referencias) ============== */
 47 | export const PIXELS_PER_UNIT     = 10;
 48 | export const HEX_UNITS_WORKER_10 = 60;
 49 | 
 50 | /* ======================================================= */
 51 | export type Cfg = {
 52 |   initialWorkers: number; initialBuilder: boolean;
 53 |   workerCost: number; builderCost: number;
 54 |   moveDistanceUnitPx: number; moveCostPctPerUnit: number; maxSpeed: number; paralysisTicks: number; helpTransferMaxPct: number; unitToEnergyPct: number;
 55 |   baseCommRadiusPx: number; commRadiusMaxPx: number;
 56 |   pixelsPerUnit: number; hexUnitsFor10: number; workerHexVisualScale: number;
 57 | };
 58 | 
 59 | export const defaultCfg: Cfg = {
 60 |   initialWorkers: 3, initialBuilder: true,
 61 |   workerCost: 10, builderCost: 10,
 62 |   moveDistanceUnitPx: 100, moveCostPctPerUnit: 0.5, maxSpeed: 1.8, paralysisTicks: 300, helpTransferMaxPct: 60, unitToEnergyPct: 0.5,
 63 |   baseCommRadiusPx: 36, commRadiusMaxPx: 220,
 64 |   pixelsPerUnit: 10, hexUnitsFor10: 60, workerHexVisualScale: 0.75,
 65 | };
 66 | 
 67 | export const EGG_COST_FOOD = 2;
 68 | 
 69 | export const FOOD_DROP_UNITS = 25;
 70 | export const PICKUP_RADIUS = 10;   // px para recoger
 71 | export const DROP_RADIUS   = 12;   // px para depositar
 72 | export const SEEK_K        = 0.06; // "atracción" por tick
 73 | export const MAX_SPEED     = 1.8;  // px/tick máximo
 74 | 
 75 | 
 76 | export const DEFAULT_FOOD_DROP = 25;
 77 | 
 78 | 
 79 | //
 80 | // === Reina: costos y ritmo (exports nombrados) ===
 81 | export const EGG_COST = 25;        // 25 und por huevo
 82 | export const EGG_LAY_PERIOD = 30;  // 30 ticks por huevo
 83 | export const MAX_EGGS_AT_QUEEN = 6;// tope de huevos renderizados en la reina
 84 | 
 85 | 


## Carpeta: contenido

--- contenido\Patrones.ts  (4 KB)
  1 | export type PatternKind =
  2 |   | "triad" | "hive7" | "hive19" | "stair" | "arc" | "vee" | "blob" | "random";
  3 | 
  4 | export type StampOpts = {
  5 |   kind?: PatternKind;
  6 |   cellSize?: number;
  7 |   amountPerCell?: number;
  8 |   rotation?: number;
  9 |   mirror?: boolean;
 10 |   jitter?: number;
 11 | };
 12 | 
 13 | type Axial = [number, number];
 14 | 
 15 | function axialToPixel(q: number, r: number, size: number) {
 16 |   const x = size * (Math.sqrt(3) * q + (Math.sqrt(3) / 2) * r);
 17 |   const y = size * ((3 / 2) * r);
 18 |   return { x, y };
 19 | }
 20 | function rotateAxial([q, r]: Axial, times: number): Axial {
 21 |   let x = q, z = r, y = -x - z;
 22 |   const rot = ((times % 6) + 6) % 6;
 23 |   for (let i = 0; i < rot; i++) {
 24 |     const nx = -z, ny = -x, nz = -y;
 25 |     x = nx; y = ny; z = nz;
 26 |   }
 27 |   return [x, z];
 28 | }
 29 | function mirrorAxial([q, r]: Axial): Axial { return [-q, r]; }
 30 | function hexDisk(radius: number): Axial[] {
 31 |   const out: Axial[] = [];
 32 |   for (let q = -radius; q <= radius; q++) {
 33 |     const r1 = Math.max(-radius, -q - radius);
 34 |     const r2 = Math.min(radius, -q + radius);
 35 |     for (let r = r1; r <= r2; r++) out.push([q, r]);
 36 |   }
 37 |   return out;
 38 | }
 39 | function hexRing(radius: number): Axial[] {
 40 |   if (radius <= 0) return [[0, 0]];
 41 |   const dirs: Axial[] = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
 42 |   let q = -radius, r = radius;
 43 |   const res: Axial[] = [];
 44 |   for (let d = 0; d < 6; d++) {
 45 |     for (let i = 0; i < radius; i++) { res.push([q,r]); q += dirs[d][0]; r += dirs[d][1]; }
 46 |   }
 47 |   return res;
 48 | }
 49 | function pat_triad(): Axial[] { return [[0,0],[1,0],[0,1]]; }
 50 | function pat_hive7(): Axial[] { return hexDisk(1); }
 51 | function pat_hive19(): Axial[] { return hexDisk(2); }
 52 | function pat_stair(): Axial[] {
 53 |   const dirs: Axial[] = [[1,0],[1,-1]];
 54 |   const out: Axial[] = [[0,0]];
 55 |   let q = 0, r = 0;
 56 |   for (let i = 0; i < 7; i++) { const d = dirs[i%2]; q += d[0]; r += d[1]; out.push([q,r]); }
 57 |   return out;
 58 | }
 59 | function pat_arc(): Axial[] {
 60 |   const ring = hexRing(3);
 61 |   const take = Math.floor(ring.length / 3);
 62 |   const start = Math.floor(Math.random() * ring.length);
 63 |   const out: Axial[] = [];
 64 |   for (let i = 0; i < take; i++) out.push(ring[(start + i) % ring.length]);
 65 |   out.push([0,0]); return out;
 66 | }
 67 | function pat_vee(): Axial[] {
 68 |   const A: Axial[] = [[0,0],[1,0],[2,0],[3,0]];
 69 |   const B: Axial[] = [[0,0],[0,1],[0,2],[0,3]];
 70 |   return [[0,0], ...A.slice(1), ...B.slice(1)];
 71 | }
 72 | function pat_blob(): Axial[] {
 73 |   const dirs: Axial[] = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
 74 |   const steps = 18 + Math.floor(Math.random()*10);
 75 |   let q=0, r=0; const set=new Set<string>(); set.add("0,0");
 76 |   for (let i=0;i<steps;i++){ const d=dirs[Math.floor(Math.random()*6)]; q+=d[0]; r+=d[1]; set.add(`${q},${r}`); }
 77 |   return Array.from(set).map(s=>s.split(",").map(Number) as Axial);
 78 | }
 79 | const LIB: Record<Exclude<PatternKind,"random">, () => Axial[]> = {
 80 |   triad: pat_triad, hive7: pat_hive7, hive19: pat_hive19,
 81 |   stair: pat_stair, arc: pat_arc, vee: pat_vee, blob: pat_blob,
 82 | };
 83 | 
 84 | export type WorldLike = { food: Array<{ x:number; y:number; amount:number; initial:number }> };
 85 | 
 86 | export function stampFoodPattern(
 87 |   world: WorldLike,
 88 |   cx: number,
 89 |   cy: number,
 90 |   opts: StampOpts = {}
 91 | ){
 92 |   const {
 93 |     kind="random", cellSize=22, amountPerCell=10, jitter=0.8,
 94 |     rotation=Math.floor(Math.random()*6), mirror=Math.random()<0.5,
 95 |   } = opts;
 96 | 
 97 |   const pickKind: Exclude<PatternKind,"random"> =
 98 |     kind === "random"
 99 |       ? (["triad","hive7","hive19","stair","arc","vee","blob"][Math.floor(Math.random()*7)] as any)
100 |       : kind;
101 | 
102 |   let cells = LIB[pickKind]();
103 |   cells = cells.map(a => rotateAxial(a, rotation));
104 |   if (mirror) cells = cells.map(mirrorAxial);
105 | 
106 |   const uniq = new Map<string, Axial>();
107 |   for (const c of cells) uniq.set(`${c[0]},${c[1]}`, c);
108 | 
109 |   for (const [q, r] of uniq.values()) {
110 |     const { x, y } = axialToPixel(q, r, cellSize);
111 |     const jx = (Math.random()*2-1) * jitter;
112 |     const jy = (Math.random()*2-1) * jitter;
113 |     world.food.push({ x: cx + x + jx, y: cy + y + jy, amount: amountPerCell, initial: amountPerCell });
114 |   }
115 | }


## Carpeta: inteligencia\cerebros

--- inteligencia\cerebros\BuilderBrain.ts  (2.8 KB)
  1 | import type { World, Ant, Hex } from "../../../tipos";
  2 | 
  3 | // Transporte por viaje (puedes ajustar)
  4 | const BUILDER_CARRY = 10;
  5 | 
  6 | // helpers locales (coinciden con los que usas en workers)
  7 | const d2 = (dx:number, dy:number) => dx*dx + dy*dy;
  8 | function approach(a: any, tx:number, ty:number, k = 0.012){
  9 |   a.vx = (a.vx ?? 0) + (tx - a.x) * k;
 10 |   a.vy = (a.vy ?? 0) + (ty - a.y) * k;
 11 |   a.x += a.vx; a.y += a.vy;
 12 |   a.vx *= 0.85; a.vy *= 0.85;
 13 | }
 14 | 
 15 | // Busca hex de la reina
 16 | function queenHex(w:World): Hex | null {
 17 |   return (w.hexes.find(h => (h as any).host === "queen") as Hex) ?? null;
 18 | }
 19 | 
 20 | // Hex objetivo de construcción (por meta o el primero incompleto)
 21 | function targetHex(w:World): Hex | null {
 22 |   const metaId = w.meta?.broodTargetHexId ?? null;
 23 |   let t = w.hexes.find(h => h.id === metaId && (h as any).completed === false) as Hex | undefined;
 24 |   if (!t) t = w.hexes.find(h => (h as any).completed === false && ((h as any).targetUnits ?? 0) > ((h as any).builtUnits ?? 0)) as Hex | undefined;
 25 |   return (t ?? null);
 26 | }
 27 | 
 28 | /** Cerebro de constructora: shuttling entre reina y obra. */
 29 | export function builderBrain(w:World, ant:Ant, _cx:number, _cy:number){
 30 |   if (ant.kind !== "builder") return;
 31 | 
 32 |   const q = queenHex(w);
 33 |   const t = targetHex(w);
 34 | 
 35 |   // Si no hay objetivo o reina: orbitar suave la reina
 36 |   if (!q || !t){
 37 |     const R = 30, wv = 0.02 * ((w as any)._tick ?? 0);
 38 |     const tx = (q?.cx ?? ant.x) + Math.cos(wv)*R;
 39 |     const ty = (q?.cy ?? ant.y) + Math.sin(wv)*R;
 40 |     approach(ant as any, tx, ty, 0.01);
 41 |     return;
 42 |   }
 43 | 
 44 |   // ¿Voy cargado? -> ir a obra y entregar
 45 |   if ((ant as any).carryingUnits > 0){
 46 |     approach(ant as any, t.cx, t.cy, 0.014);
 47 |     const near = d2((ant.x - t.cx), (ant.y - t.cy)) < (t.sidePx*t.sidePx*0.25);
 48 |     if (near){
 49 |       const built  = ((t as any).builtUnits ?? 0);
 50 |       const target = ((t as any).targetUnits ?? 100);
 51 |       const room   = Math.max(0, target - built);
 52 |       const give   = Math.min(room, (ant as any).carryingUnits);
 53 | 
 54 |       (t as any).builtUnits = built + give;
 55 |       (ant as any).carryingUnits -= give;
 56 | 
 57 |       if ((t as any).builtUnits >= target){
 58 |         (t as any).builtUnits = target;
 59 |         (t as any).completed = true;
 60 |         if (w.meta){
 61 |           w.meta.broodTransferPending = false;
 62 |           w.meta.broodTargetHexId = null;
 63 |         }
 64 |       }
 65 |     }
 66 |     return;
 67 |   }
 68 | 
 69 |   // Voy vacío -> ir a la reina y recoger del banco
 70 |   approach(ant as any, q.cx, q.cy, 0.014);
 71 |   const nearQ = d2((ant.x - q.cx), (ant.y - q.cy)) < (q.sidePx*q.sidePx*0.25);
 72 |   if (nearQ){
 73 |     const bank = (w.stockFood ?? 0);
 74 |     if (bank > 0){
 75 |       const take = Math.min(BUILDER_CARRY, bank);
 76 |       w.stockFood = bank - take;
 77 |       w.stockTotal = (w.stockTotal ?? 0) + 0; // (solo acumulador histórico si quieres)
 78 |       (ant as any).carryingUnits = take;
 79 |     }
 80 |   }
 81 | }

--- inteligencia\cerebros\Cerebros.ts  (8.8 KB)
  1 | import type { World, Ant, Hex } from "../../../tipos";
  2 | import { CARRY_PER_TRIP, PICKUP_RADIUS, DROP_RADIUS, SEEK_K, MAX_SPEED } from "../../configuracion/predeterminados";
  3 | 
  4 | // utilidades locales simples
  5 | const d2 = (dx:number,dy:number)=>dx*dx+dy*dy;
  6 | const approach = (a:Ant, tx:number, ty:number, k=0.015)=>{
  7 |   a.vx = (a.vx??0) + (tx - a.x) * k;
  8 |   a.vy = (a.vy??0) + (ty - a.y) * k;
  9 |   a.x += a.vx; a.y += a.vy;
 10 | };
 11 | 
 12 | // === OBRERA: igual que tenías (memoria básica de recolección) ===
 13 | export function workerBrain(w:World, ant:Ant){
 14 |   const a:any = ant;
 15 |   const Q = w.hexes.find(h=>h.host==="queen");
 16 |   if (!Q) return;
 17 | 
 18 |   // acercamiento con "snap" y límite de velocidad
 19 |   const approachClamp = (ax:any, tx:number, ty:number):boolean => {
 20 |     const dx = tx - ax.x, dy = ty - ax.y;
 21 |     const d  = Math.hypot(dx, dy);
 22 |     if (d < 1.5){ // llegó
 23 |       ax.x = tx; ax.y = ty;
 24 |       ax.vx = (ax.vx ?? 0) * 0.4;
 25 |       ax.vy = (ax.vy ?? 0) * 0.4;
 26 |       return true;
 27 |     }
 28 |     ax.vx = (ax.vx ?? 0) + dx * SEEK_K;
 29 |     ax.vy = (ax.vy ?? 0) + dy * SEEK_K;
 30 |     const sp = Math.hypot(ax.vx, ax.vy);
 31 |     if (sp > MAX_SPEED){ ax.vx *= MAX_SPEED/sp; ax.vy *= MAX_SPEED/sp; }
 32 |     ax.x += ax.vx; ax.y += ax.vy;
 33 |     return false;
 34 |   };
 35 | 
 36 |   const nearestFood = ():any => {
 37 |     let best:any = null, bd = Infinity;
 38 |     for (const f of w.food){
 39 |       const rem = f.amount ?? 0; if (rem <= 0) continue;
 40 |       const dx = f.x - a.x, dy = f.y - a.y;
 41 |       const d  = dx*dx + dy*dy;
 42 |       if (d < bd){ bd = d; best = f; }
 43 |     }
 44 |     return best;
 45 |   };
 46 | 
 47 |   a.state = a.state ?? "seekFood";
 48 | 
 49 |   // Sin carga -> buscar comida (mantiene target si aún existe)
 50 |   if ((a.carryingUnits ?? 0) <= 0){
 51 |     if (!a._target || (a._target.amount ?? 0) <= 0){
 52 |       a._target = nearestFood();
 53 |       if (!a._target){
 54 |         // Letargo suave: volver a su hex (o reina) con pequeñísimo bamboleo
 55 |         const home = a.homeHexId ? (w.hexes.find(h=>h.id===a.homeHexId) ?? Q) : Q;
 56 |         approachClamp(a, home.cx + Math.sin((w as any)._tick*0.01)*3, home.cy + Math.cos((w as any)._tick*0.013)*3);
 57 |         return;
 58 |       }
 59 |     }
 60 |     const arrived = approachClamp(a, a._target.x, a._target.y);
 61 |     if (arrived || Math.hypot(a._target.x - a.x, a._target.y - a.y) < PICKUP_RADIUS){
 62 |       const take = Math.min(CARRY_PER_TRIP, a._target.amount ?? 0);
 63 |       if (take > 0){
 64 |         a._target.amount -= take;
 65 |         a.carryingUnits = take;
 66 |       }else{
 67 |         a._target = null;
 68 |       }
 69 |     }
 70 |   } else {
 71 |     // Con carga -> volver a la reina y depositar en Banco
 72 |     const arrived = approachClamp(a, Q.cx, Q.cy);
 73 |     if (arrived || Math.hypot(Q.cx - a.x, Q.cy - a.y) < DROP_RADIUS){
 74 |       const cu = a.carryingUnits ?? 0;
 75 |       if (cu > 0){
 76 |         w.stockFood  = (w.stockFood  ?? 0) + cu;
 77 |         w.stockTotal = (w.stockTotal ?? 0) + cu;
 78 |         a.carryingUnits = 0;
 79 |       }
 80 |       a._target = null;
 81 |     }
 82 |   }
 83 | }
 84 | 
 85 | // === CONSTRUCTORA: traslada huevos de la reina al hex objetivo ===
 86 | export function builderBrain(w:World, ant:Ant, _cx?:number, _cy?:number){
 87 |   const Q = w.hexes.find(h=>h.host==="queen");
 88 |   const m = w.meta;
 89 |   if (!Q || !m) return;
 90 | 
 91 |   // no hay traslado pendiente
 92 |   if (!m.broodTransferPending || !m.broodTargetHexId) return;
 93 | 
 94 |   const T = w.hexes.find(h=>h.id===m.broodTargetHexId) as Hex|undefined;
 95 |   if (!T) return;
 96 | 
 97 |   // Inicializa estructura de eggs en el target por si acaso
 98 |   (T as any).eggs = (T as any).eggs ?? { active:false, fed:0, tStart:(w as any)._tick??0, born:0, spots:[] };
 99 | 
100 |   // 1) si no lleva huevo y aún hay huevos en la reina, ir a la reina y "cargar" uno
101 |   if (!(ant as any).carryEgg){
102 |     if (m.broodEggsStaged <= 0){ m.broodTransferPending = false; return; }
103 |     approach(ant, Q.cx, Q.cy, 0.02);
104 |     if (Math.hypot(ant.x-Q.cx, ant.y-Q.cy) < Q.sidePx*0.55){
105 |       // toma un huevo
106 |       (ant as any).carryEgg = true;
107 |       m.broodEggsStaged -= 1;
108 |     }
109 |     return;
110 |   }
111 | 
112 |   // 2) si lleva huevo, ir al hex objetivo
113 |   approach(ant, T.cx, T.cy, 0.02);
114 |   if (Math.hypot(ant.x-T.cx, ant.y-T.cy) < T.sidePx*0.55){
115 |     // soltar huevo y marcarlo visible en un spot
116 |     const E:any = (T as any).eggs;
117 |     if (!E.spots || E.spots.length===0){
118 |       // fallback: generar spots si no existen (no debería pasar, pero por si acaso)
119 |       const r = T.sidePx*0.42;
120 |       E.spots = [];
121 |       for (let i=0;i<6;i++){
122 |         const a = Math.PI/6 + i*(Math.PI/3);
123 |         E.spots.push({x:T.cx+Math.cos(a)*r, y:T.cy+Math.sin(a)*r});
124 |       }
125 |     }
126 |     E.born = (E.born??0) + 1;   // MotorDeRender dibuja tantos puntos naranjas como "born"
127 |     E.active = true;
128 |     (ant as any).carryEgg = false;
129 | 
130 |     // ¿completamos los 6? fin del traslado
131 |     if (E.born>=6){
132 |       m.broodTransferPending = false;
133 |       m.broodTargetHexId = null;
134 |       // aquí NO eclosionan aún: eso lo maneja tu SistemaCria cuando alimentes
135 |     }
136 |   }
137 | }
138 | 
139 | 
140 | 
141 | /* ======================= NURSE BRAIN ======================= */
142 | 
143 | const NURSE_FEED_STEP = 5;        // alimenta de 5 en 5
144 | const NURSE_FEED_FULL = 25;       // 25 und para eclosionar
145 | const HATCH_WAIT_TICKS = 45 * 60; // 45s si 60 ticks/seg (ajústalo si tu reloj es distinto)
146 | 
147 | // utilidades locales sin tocar otras IA
148 | function _q(w:World){ return w.hexes.find(h => (h as any).host === "queen") ?? null; }
149 | function _d2(ax:number, ay:number, bx:number, by:number){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }
150 | function _approach(a:any, tx:number, ty:number, k:number, vmax=1.25){
151 |   a.vx = (a.vx ?? 0) + (tx - a.x) * k;
152 |   a.vy = (a.vy ?? 0) + (ty - a.y) * k;
153 |   const sp = Math.hypot(a.vx, a.vy);
154 |   if (sp > vmax) { a.vx *= vmax/sp; a.vy *= vmax/sp; }
155 |   a.x += a.vx; a.y += a.vy;
156 | }
157 | 
158 | /** Nurse: mueve huevos, alimenta, gestiona 4 nidos y late cuando está en reposo. */
159 | export function nurseBrain(w:World, ant:Ant){
160 |   const A:any = ant as any;
161 |   const Q = _q(w); if (!Q) return;
162 | 
163 |   // velocidad ~ mitad del worker (k pequeño y vmax menor)
164 |   const K = 0.006; const VMAX = 1.25;
165 | 
166 |   // halo pulsante en latencia
167 |   A.pulse = A.pulse ?? 0.9;
168 |   A._pulseDir = A._pulseDir ?? -1;
169 | 
170 |   // asignación de hasta 4 nidos (hex no-queen). Se mantiene viva al desaparecer/crearse hex.
171 |   A.nests = (A.nests ?? []).filter((id:number)=> w.hexes.some(h => (h as any).id === id));
172 |   if (A.nests.length < 4){
173 |     for (const h of w.hexes){
174 |       if ((h as any).host === "queen") continue;
175 |       const id = (h as any).id;
176 |       if (!A.nests.includes(id)) A.nests.push(id);
177 |       if (A.nests.length >= 4) break;
178 |     }
179 |   }
180 |   const nests = (A.nests as number[])
181 |     .map(id => w.hexes.find(h => (h as any).id === id))
182 |     .filter(Boolean) as any[];
183 | 
184 |   const eggs:any[] = (w as any).eggs ?? [];
185 |   const atQueen = eggs.find(e => e.state === "atQueen");
186 | 
187 |   // 1) Si va cargando huevo => ir al primer nido disponible y soltar
188 |   if (A.carryEggId != null){
189 |     const egg = eggs.find(e => e.id === A.carryEggId);
190 |     const nest = nests[0];
191 |     if (!egg || !nest){ A.carryEggId = null; return; }
192 | 
193 |     _approach(A, nest.cx, nest.cy, K, VMAX);
194 |     const near = _d2(A.x, A.y, nest.cx, nest.cy) < (nest.sidePx * nest.sidePx * 0.12);
195 |     if (near){
196 |       egg.state = "incubating";
197 |       egg.targetHexId = nest.id;
198 |       egg.fedUnd = egg.fedUnd ?? 0;
199 |       egg.tStart = (w as any)._tick ?? 0;
200 |       egg.hatchAt = egg.tStart + HATCH_WAIT_TICKS;
201 |       A.carryEggId = null;
202 |     }
203 |     return;
204 |   }
205 | 
206 |   // 2) Si hay huevo en la reina y hay nidos, ir por él y cargarlo
207 |   if (atQueen && nests.length > 0){
208 |     _approach(A, Q.cx, Q.cy, K, VMAX);
209 |     const nearQ = _d2(A.x, A.y, Q.cx, Q.cy) < (Q.sidePx * Q.sidePx * 0.12);
210 |     if (nearQ){
211 |       A.carryEggId = atQueen.id;
212 |       atQueen.state = "carried";
213 |     }
214 |     return;
215 |   }
216 | 
217 |   // 3) Alimentación: busca huevos incubando en sus nidos y sube de 5 en 5 hasta 25
218 |   const hungry = eggs.find(e => e.state === "incubating" && (A.nests ?? []).includes((e as any).targetHexId) && ((e.fedUnd ?? 0) < NURSE_FEED_FULL));
219 |   if (hungry){
220 |     const nest = w.hexes.find(h => (h as any).id === (hungry as any).targetHexId) as any;
221 |     if (nest){
222 |       _approach(A, nest.cx, nest.cy, K, VMAX);
223 |       const near = _d2(A.x, A.y, nest.cx, nest.cy) < (nest.sidePx * nest.sidePx * 0.12);
224 |       if (near){
225 |         const bank = (w as any).stockFood ?? 0;
226 |         if (bank >= NURSE_FEED_STEP){
227 |           (w as any).stockFood = bank - NURSE_FEED_STEP;
228 |           hungry.fedUnd = Math.min(NURSE_FEED_FULL, (hungry.fedUnd ?? 0) + NURSE_FEED_STEP);
229 |         }
230 |       }
231 |     }
232 |     return;
233 |   }
234 | 
235 |   // 4) Latencia: ir al primer nido asignado (o a la reina si no hay) y hacer pulso
236 |   const idleTarget:any = nests[0] ?? Q;
237 |   _approach(A, idleTarget.cx, idleTarget.cy, K, VMAX);
238 | 
239 |   // pulso del glow (0.3..1.0)
240 |   A.pulse += 0.02 * (A._pulseDir ?? -1);
241 |   if (A.pulse < 0.3) { A.pulse = 0.3; A._pulseDir = 1; }
242 |   else if (A.pulse > 1.0){ A.pulse = 1.0; A._pulseDir = -1; }
243 | }
244 | 
245 | 
246 | 
247 | 
248 | 


## Carpeta: shared

--- shared\roles.ts  (1 KB)
  1 | export type RolCanonico = "obrera" | "nurse" | "constructora" | "soldado" | "reina";
  2 | 
  3 | /** Devuelve un rol canÃ³nico sin importar cÃ³mo llegue escrito. */
  4 | export function normalizeRole(r: unknown): RolCanonico {
  5 |   const s = String(r ?? "").trim().toLowerCase();
  6 | 
  7 |   if (["constructora","constructor","builder","build","constructoras"].includes(s)) return "constructora";
  8 |   if (["obrera","worker","workers"].includes(s)) return "obrera";
  9 |   if (["nurse","nurses","nodriza","nodrizas"].includes(s)) return "nurse";
 10 |   if (["soldado","soldier","soldiers"].includes(s)) return "soldado";
 11 |   if (["reina","queen"].includes(s)) return "reina";
 12 | 
 13 |   return "obrera";
 14 | }
 15 | 
 16 | /** Glyph por rol (ajÃºstalo a tu estilo de UI) */
 17 | export function glyphByRole(r: unknown): string {
 18 |   switch (normalizeRole(r)) {
 19 |     case "constructora": return "B"; // Builder
 20 |     case "obrera":       return "W";
 21 |     case "nurse":        return "N";
 22 |     case "soldado":      return "S";
 23 |     case "reina":        return "Q";
 24 |   }
 25 | }


## Carpeta: sistemas

--- sistemas\index.ts  (1.1 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | import { SistemaSemilla } from "./SistemaSemilla";
  5 | import { SistemaReina } from "./SistemaReina";
  6 | import { SistemaIA } from "./SistemaIA";
  7 | import { SistemaMetabolismo } from "./SistemaMetabolismo";
  8 | 
  9 | import { SistemaPlanificacion } from "./SistemaPlanificacion";
 10 | import { SistemaBuilder } from "./SistemaBuilder";
 11 | import { SistemaNurse } from "./SistemaNurse";
 12 | 
 13 | 
 14 | export function ejecutarSistemas(w: World, cfg: Cfg) {
 15 |   (w as any)._tick = ((w as any)._tick ?? 0) + 1;
 16 | 
 17 |   // 1) Semilla (3 obreras + 1 constructora)
 18 |   SistemaSemilla(w, cfg);
 19 | 
 20 |   // 2) Reina (pone huevos y cobra del banco)
 21 |   SistemaReina(w, cfg);
 22 | 
 23 |   // 3) Planificar nuevo hex si hay 6 huevos en la reina y una constructora
 24 |   SistemaPlanificacion(w, cfg);
 25 | 
 26 |   SistemaNurse(w, cfg);
 27 | 
 28 |   // 4) Construcción: la constructora avanza el hex objetivo consumiendo banco
 29 |   SistemaBuilder(w, cfg);
 30 | 
 31 |   // 5) IA de hormigas (forrajeo, etc.)
 32 |   if (typeof SistemaIA === "function") SistemaIA(w, cfg);
 33 | 
 34 |   // 6) Metabolismo, etc.
 35 |   if (typeof SistemaMetabolismo === "function") SistemaMetabolismo(w, cfg);
 36 | }

--- sistemas\README.md  (0.1 KB)
  1 | # Placeholder Lote A
  2 | Esta carpeta se llenará en los lotes siguientes. Mantener nombres sencillos.

--- sistemas\SistemaAccionMover.ts  (0.5 KB)
  1 | /** SistemaAccionMover  integra posición y limita velocidad. */
  2 | import type { World } from "../../tipos";
  3 | 
  4 | export function SistemaAccionMover(w:World, _dt:number, maxSpeed:number){
  5 |   for (const a of w.ants){
  6 |     if (a.state === "dead") continue;
  7 | 
  8 |     // fricción suave
  9 |     a.vx *= 0.995;
 10 |     a.vy *= 0.995;
 11 | 
 12 |     // tope de velocidad
 13 |     const sp = Math.hypot(a.vx, a.vy);
 14 |     if (sp > maxSpeed){
 15 |       a.vx = (a.vx / sp) * maxSpeed;
 16 |       a.vy = (a.vy / sp) * maxSpeed;
 17 |     }
 18 | 
 19 |     // integrar
 20 |     a.x += a.vx;
 21 |     a.y += a.vy;
 22 |   }
 23 | }

--- sistemas\SistemaBuilder.ts  (1 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | const BUILD_COST_DEFAULT = 100;
  5 | const BUILD_RATE_PER_TICK = 2; // cuántas und del coste se construye por tick
  6 | 
  7 | export function SistemaBuilder(w: World, _cfg: Cfg) {
  8 |   const m: any = (w as any).meta;
  9 |   if (!m?.buildTargetHexId) return;
 10 | 
 11 |   const h = w.hexes.find(x => x.id === m.buildTargetHexId) as any;
 12 |   if (!h) { m.buildTargetHexId = null; return; }
 13 |   if (h.completed) { m.buildTargetHexId = null; return; }
 14 | 
 15 |   const bank = (w as any).stockFood ?? 0;
 16 |   if (bank <= 0) return;
 17 | 
 18 |   const target = h.targetUnits ?? BUILD_COST_DEFAULT;
 19 |   const built = h.builtUnits ?? 0;
 20 |   const need  = Math.max(0, target - built);
 21 |   if (need <= 0) { h.completed = true; m.buildTargetHexId = null; return; }
 22 | 
 23 |   const step = Math.min(BUILD_RATE_PER_TICK, need, bank);
 24 |   h.builtUnits = built + step;
 25 |   (w as any).stockFood = bank - step;
 26 | 
 27 |   if (h.builtUnits >= target) {
 28 |     h.completed = true;
 29 |     m.buildTargetHexId = null;
 30 |   }
 31 | }

--- sistemas\SistemaCria.ts  (2.2 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | import { EGGS_NEED_UND, HATCH_TIME } from "../configuracion/predeterminados";
  4 | 
  5 | /**
  6 |  * Mantiene el ciclo de los huevos:
  7 |  * - Si no se alimentan, expiran tras TTL.
  8 |  * - Si se alimentan >= EGGS_NEED_UND, cuenta regresiva de hatch y eclosión.
  9 |  *
 10 |  * Nota: usamos un TTL local de 5 min @ 60 FPS para evitar dependencias:
 11 |  */
 12 | const EGGS_TTL_TICKS = 5 * 60 * 60; // 5 min * 60 s/min * 60 ticks/s
 13 | 
 14 | export function SistemaCria(w: World, _cfg: Cfg) {
 15 |   for (const h of w.hexes) {
 16 |     if (!h.eggs || !h.eggs.active) continue;
 17 | 
 18 |     // TTL si no se alimenta
 19 |     h.eggs.ageTicks = (h.eggs.ageTicks ?? 0) + 1;
 20 |     if ((h.eggs.fed ?? 0) < EGGS_NEED_UND && (h.eggs.ageTicks ?? 0) >= EGGS_TTL_TICKS) {
 21 |       // Caducan por falta de alimento
 22 |       h.eggs.active = false;
 23 |       h.eggs.count = 0;
 24 |       continue;
 25 |     }
 26 | 
 27 |     // Eclosión si está alimentado
 28 |     if ((h.eggs.fed ?? 0) >= EGGS_NEED_UND) {
 29 |       // Asegura hatchTicks inicial
 30 |       h.eggs.hatchTicks = (h.eggs.hatchTicks ?? HATCH_TIME);
 31 | 
 32 |       // Decrementa de forma segura
 33 |       if ((h.eggs.hatchTicks ?? 0) > 0) {
 34 |         h.eggs.hatchTicks = (h.eggs.hatchTicks as number) - 1;
 35 |       }
 36 | 
 37 |       // ¿Listo para eclosionar?
 38 |       if ((h.eggs.hatchTicks ?? 0) <= 0) {
 39 |         const workers  = w.ants.filter(a => a.kind === "worker").length;
 40 |         const builders = w.ants.filter(a => a.kind === "builder").length;
 41 | 
 42 |         // Mantén tu regla de builder 1/10 workers
 43 |         const wantBuilder = builders < Math.floor(workers / 10);
 44 |         const makeBuilders = wantBuilder ? Math.min(1, h.eggs.count ?? 0) : 0;
 45 |         const makeWorkers  = Math.max(0, (h.eggs.count ?? 0) - makeBuilders);
 46 | 
 47 |         // Aquí normalmente generarías hormigas y limpiarías el lote.
 48 |         // Dejo el cierre no destructivo para no duplicar spawns si los manejas en otro sistema:
 49 |         h.eggs.active = false;
 50 |         // Si aquí quieres spawnear directamente, usa tu fábrica newAnt(...) y pushea:
 51 |         // for (let i=0;i<makeBuilders;i++) { ... }
 52 |         // for (let i=0;i<makeWorkers;i++)  { ... }
 53 |       }
 54 |     }
 55 |   }
 56 | }

--- sistemas\SistemaCriaLogistica.ts  (0.2 KB)
  1 | import type { World } from "../../tipos";
  2 | 
  3 | // La constructora lo hace en builderBrain.
  4 | // Dejar no-op para no interferir.
  5 | export function SistemaCriaLogistica(_w:World){ /* no-op */ }

--- sistemas\SistemaDecision.ts  (0.3 KB)
  1 | /** SistemaDecision  Lote D: asegura estados base. */
  2 | import { World } from "../../tipos";
  3 | export function SistemaDecision(w:World, _dt:number){
  4 |   for(const a of w.ants){
  5 |     if (a.state === "waiting") a.state = "foraging";
  6 |     if (a.state === "dead") continue;
  7 |   }
  8 | }

--- sistemas\SistemaEconomia.ts  (0.6 KB)
  1 | import type { World } from "../../tipos";
  2 | 
  3 | /** Al tocar la reina, las hormigas depositan sus carryingUnits al banco (w.stockFood). */
  4 | export function SistemaEconomia(w:World){
  5 |   const q = w.hexes.find(h=>h.host==="queen");
  6 |   if (!q) return;
  7 |   w.stockFood = w.stockFood ?? 0;
  8 | 
  9 |   for (const a of w.ants){
 10 |     if (!a.carryingUnits || a.carryingUnits <= 0) continue;
 11 |     const dx = a.x - q.cx, dy = a.y - q.cy;
 12 |     if (dx*dx + dy*dy <= (q.sidePx*q.sidePx)*0.3){
 13 |       w.stockFood += a.carryingUnits;
 14 |       a.carryingUnits = 0;
 15 |       a.state = "foraging";
 16 |     }
 17 |   }
 18 | }

--- sistemas\SistemaEntrada.ts  (0.7 KB)
  1 | /**
  2 |  * SistemaEntrada  helpers que invoca la UI (Aplicacion.tsx).
  3 |  * Click derecho: comida (10). Shift: patrón. Ctrl: peligro.
  4 |  */
  5 | import type { World } from "../../tipos";
  6 | import { stampFoodPattern } from "../contenido/Patrones";
  7 | 
  8 | export function placeFood(w:World, x:number, y:number, amount=10){
  9 |   const __tmp = {  x, y, amount, initial: amount  }; ( __tmp as any ).outside = true; w.food.push(__tmp);
 10 | }
 11 | export function placePattern(w:World, x:number, y:number){
 12 |   stampFoodPattern(w, x, y, { kind:"random", cellSize:24, amountPerCell:10 });
 13 | }
 14 | export function placeHazard(w:World, x:number, y:number){
 15 |   w.hazards.push({
 16 |     x, y, r: 12, hp: 100,
 17 |     vx: (Math.random()*0.6-0.3),
 18 |     vy: (Math.random()*0.6-0.3)
 19 |   });
 20 | }
 21 | 
 22 | 

--- sistemas\SistemaFeromonas.ts  (0.9 KB)
  1 | import type { World } from '../../tipos';
  2 | import { MAX_BEACONS, BEACON_TTL_FOOD } from '../configuracion/predeterminados';
  3 | 
  4 | export function SistemaFeromonas(w:World){
  5 |   const t = (w as any)._tick ?? 0;
  6 | 
  7 |   // Decaimiento suave
  8 |   if ((t % 4) === 0){
  9 |     for (let i=w.beacons.length-1; i>=0; i--){
 10 |       const b = w.beacons[i];
 11 |       b.strength *= b.decay ?? 0.97;
 12 |       b.ttl = (b.ttl ?? BEACON_TTL_FOOD) - 4;
 13 |       if (b.strength < 0.05 || b.ttl <= 0) w.beacons.splice(i,1);
 14 |     }
 15 |   }
 16 | 
 17 |   // Limitar cantidad
 18 |   if (w.beacons.length > MAX_BEACONS){
 19 |     w.beacons.splice(0, w.beacons.length - MAX_BEACONS);
 20 |   }
 21 | 
 22 |   // Emisión pasiva desde nodos de comida
 23 |   if ((t % 30) === 0){
 24 |     for (const f of w.food){
 25 |       if (f.amount <= 0) continue;
 26 |       const s = Math.min(1, f.amount / 50);
 27 |       w.beacons.push({ x:f.x, y:f.y, strength: 0.5*s, decay: 0.97, ttl: BEACON_TTL_FOOD });
 28 |     }
 29 |   }
 30 | }

--- sistemas\SistemaHuevos.ts  (3.4 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | /**
  5 |  * Traslado 1x1 por la constructora y espejo de conteos para render.
  6 |  * - Si hay meta.broodTransferPending + broodTargetHexId: la constructora
  7 |  *   recoge 1 huevo del hex de la reina (state:"atQueen"), lo carga (state:"carried"),
  8 |  *   y lo deja en el hex objetivo (state:"incubating").
  9 |  * - Mientras va "carried", el huevo viaja pegado a la hormiga.
 10 |  * - Se refleja h.eggs.born por hex para que el renderer actual siga mostrando puntos naranjas.
 11 |  */
 12 | export function SistemaHuevos(w:World, _cfg:Cfg){
 13 |   const tick = ((w as any)._tick ?? 0);
 14 | 
 15 |   // Asegurar estructura
 16 |   (w as any).eggs     = (w as any).eggs ?? [];
 17 |   (w as any).nextEggId= (w as any).nextEggId ?? 1;
 18 | 
 19 |   const queen = w.hexes.find(h=>h.host==="queen");
 20 |   const builder = w.ants.find(a=>a.kind==="builder");
 21 |   if (!queen) return;
 22 | 
 23 |   // Sincronizar huevos "carried": van pegados a la constructora que los lleva
 24 |   for(const e of (w.eggs as any[])){
 25 |     if (e.carriedBy != null){
 26 |       const a = w.ants.find(x=>x.id===e.carriedBy);
 27 |       if (a){ e.x = a.x; e.y = a.y; }
 28 |       else { e.carriedBy = undefined; e.state = "atQueen"; e.hexId = queen.id; }
 29 |     }
 30 |   }
 31 | 
 32 |   // Lógica de traslado 1x1
 33 |   const m = w.meta as any;
 34 |   if (m?.broodTransferPending && m?.broodTargetHexId && builder){
 35 |     const target = w.hexes.find(h=>h.id===m.broodTargetHexId);
 36 |     if (target){
 37 |       const carrying = (w.eggs as any[]).find(e=>e.carriedBy===builder.id);
 38 |       if (!carrying){
 39 |         // Ir a la reina
 40 |         approach(builder, queen.cx, queen.cy, 0.06);
 41 |         // Si estamos cerca, tomar 1 huevo "atQueen"
 42 |         const close2 = dist2(builder.x-queen.cx, builder.y-queen.cy);
 43 |         const pick = (w.eggs as any[]).find(e=>e.state==="atQueen");
 44 |         if (pick && close2 < queen.sidePx*queen.sidePx*0.25){
 45 |           pick.carriedBy = builder.id;
 46 |           pick.state = "carried";
 47 |           pick.hexId = null;
 48 |         }
 49 |       }else{
 50 |         // Llevar al hex objetivo
 51 |         approach(builder, target.cx, target.cy, 0.06);
 52 |         const close2 = dist2(builder.x-target.cx, builder.y-target.cy);
 53 |         if (close2 < target.sidePx*target.sidePx*0.25){
 54 |           carrying.carriedBy = undefined;
 55 |           carrying.state = "incubating";
 56 |           carrying.hexId = target.id;
 57 |         }
 58 |       }
 59 | 
 60 |       // Si ya hay 6 incubando en destino -> fin de traslado
 61 |       const delivered = (w.eggs as any[]).filter(e=>e.hexId===target.id && e.state==="incubating").length;
 62 |       if (delivered >= 6){
 63 |         m.broodTransferPending = false;
 64 |         m.broodTargetHexId = null;
 65 |       }
 66 |     }
 67 |   }
 68 | 
 69 |   // Espejo: reset born por hex y acumular según w.eggs
 70 |   for(const h of w.hexes){
 71 |     if (!(h as any).eggs) (h as any).eggs = { born:0, fed:0, active:true, spots:[] };
 72 |     (h as any).eggs.born = 0;
 73 |   }
 74 |   for(const e of (w.eggs as any[])){
 75 |     const hid = (e.state==="atQueen" ? queen.id : e.hexId);
 76 |     const hex = w.hexes.find(h=>h.id===hid);
 77 |     if (hex){
 78 |       if (!(hex as any).eggs) (hex as any).eggs = { born:0, fed:0, active:true, spots:[] };
 79 |       (hex as any).eggs.born = ((hex as any).eggs.born ?? 0) + 1;
 80 |     }
 81 |   }
 82 | }
 83 | 
 84 | function dist2(dx:number, dy:number){ return dx*dx + dy*dy; }
 85 | function approach(a:any, tx:number, ty:number, k=0.05){
 86 |   a.vx = (a.vx ?? 0) + (tx - a.x) * k;
 87 |   a.vy = (a.vy ?? 0) + (ty - a.y) * k;
 88 |   a.x += a.vx; a.y += a.vy;
 89 |   a.vx *= 0.86; a.vy *= 0.86;
 90 | }
 91 | 

--- sistemas\SistemaIA.ts  (0.8 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | import { workerBrain, builderBrain, nurseBrain } from "../inteligencia/cerebros/Cerebros";
  4 | 
  5 | export function SistemaIA(w: World, _cfg: Cfg){
  6 |   // centro de referencia: la reina si existe
  7 |   const q = w.hexes.find(h => (h as any).host === "queen") as any;
  8 |   const cx = q?.cx ?? 0;
  9 |   const cy = q?.cy ?? 0;
 10 | 
 11 |   // pista de comida para workerBrain (hint opcional)
 12 |   const anyFood = w.food.find(f => (f as any).amount > 0);
 13 | 
 14 |   for (const a of (w.ants as any[])) {
 15 |     if (a.kind === "worker")      workerBrain(w, a);
 16 |     else if (a.kind === "builder")builderBrain(w, a);
 17 |     else if (a.kind === "nurse")  nurseBrain(w, a);
 18 |     // soldiers, scout, kel, etc. se manejan en sus sistemas específicos
 19 |   }
 20 | }
 21 | 
 22 | 

--- sistemas\SistemaInfluencia.ts  (0.9 KB)
  1 | /** SistemaInfluencia  aplica correa suave alrededor de la reina. */
  2 | import { World } from "../../tipos";
  3 | import { INFLUENCE_BASE_PX, INFLUENCE_PER_HEX_PX } from "../configuracion/predeterminados";
  4 | 
  5 | function radioInfluencia(w:World){
  6 |   const nonQueen = w.hexes.filter(h => h.host !== "queen").length;
  7 |   return INFLUENCE_BASE_PX + nonQueen * INFLUENCE_PER_HEX_PX;
  8 | }
  9 | 
 10 | export function SistemaInfluencia(w:World, _dt:number){
 11 |   const q = w.hexes.find(h => h.host === "queen");
 12 |   if (!q) return;
 13 |   const R = radioInfluencia(w);
 14 | 
 15 |   for(const a of w.ants){
 16 |     if (a.state === "dead") continue;
 17 |     const dx = a.x - q.cx, dy = a.y - q.cy;
 18 |     const d  = Math.hypot(dx, dy) || 1;
 19 |     if (d > R){
 20 |       const over = (d - R) / R;                 // cuánto excede
 21 |       const pull = 0.08 + 0.22 * Math.min(1, over);
 22 |       a.vx -= (dx / d) * pull;
 23 |       a.vy -= (dy / d) * pull;
 24 |     }
 25 |   }
 26 | }

--- sistemas\SistemaMetabolismo.ts  (0.9 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | /** Metabolismo básico: las hormigas consumen y, si hay stock, se alimentan. */
  5 | export function SistemaMetabolismo(w: World, cfg: Cfg){
  6 |   // usa la config si existe; si no, un valor seguro por defecto
  7 |   const perTick = (cfg as any)?.metabolismUndPerTick ?? 0.02;
  8 | 
  9 |   for (const a of w.ants){
 10 |     a.hungerUnd = (a.hungerUnd ?? 0) + perTick;
 11 | 
 12 |     // si hay comida en almacén, se alimenta y reduce hambre
 13 |     const stock = (w as any).stockFood ?? 0;
 14 |     if (a.hungerUnd! > 0 && stock > 0){
 15 |       const feed = Math.min(a.hungerUnd!, stock);
 16 |       a.hungerUnd! -= feed;
 17 |       (w as any).stockFood = stock - feed;
 18 |     }
 19 | 
 20 |     // contaje de inanición (defensivo, por si algún ant no trae estas props)
 21 |     a.starveTicks = (a.hungerUnd! > 5) ? ((a.starveTicks ?? 0) + 1) : 0;
 22 |   }
 23 | }

--- sistemas\SistemaNurse.ts  (4 KB)
  1 | import type { World } from "../../tipos";
  2 | import { CARRY_PER_TRIP, EGGS_NEED_UND } from "../configuracion/predeterminados";
  3 | 
  4 | /**
  5 |  * Enfermeras: mueven huevos desde la reina hasta el hex objetivo
  6 |  * y los alimentan hasta alcanzar EGGS_NEED_UND (=25).
  7 |  * No construyen; sÃ³lo colocan y alimentan.
  8 |  */
  9 | export function SistemaNurse(w: World, _cfg?: unknown) {
 10 |   const eggs = (w as any).eggs as any[] | undefined;
 11 |   if (!eggs || eggs.length === undefined) return;
 12 | 
 13 |   const q = w.hexes.find(h => (h as any).host === "queen") as any;
 14 |   if (!q) return;
 15 | 
 16 |   // Hex objetivo = el mÃ¡s reciente que no sea la reina y no completado (builder lo prepara)
 17 |   const target = w.hexes.find(h => (h as any).host !== "queen" && !(h as any).completed) as any | undefined;
 18 | 
 19 |   for (const a of (w.ants as any[])) {
 20 |     if (a.kind !== "nurse") continue;
 21 | 
 22 |     a.state ??= "idle";
 23 |     a.carryEgg ??= false;
 24 |     a.carryingUnits ??= 0;
 25 | 
 26 |     switch (a.state) {
 27 |       case "idle": {
 28 |         const eggsAtQueen = eggs.some(e => e.state === "atQueen");
 29 |         if (eggsAtQueen && target) a.state = "toQueenEgg";
 30 |         else hoverAround(a, q.cx, q.cy);
 31 |         break;
 32 |       }
 33 | 
 34 |       case "toQueenEgg": {
 35 |         if (approach(a, q.cx, q.cy, 0.06)) {
 36 |           const eg = eggs.find(e => e.state === "atQueen");
 37 |           if (eg) {
 38 |             eg.state = "carried";
 39 |             eg.carrierId = a.id;
 40 |             a.carryEgg = true;
 41 |             a.state = "toTargetHex";
 42 |           } else {
 43 |             a.state = "idle";
 44 |           }
 45 |         }
 46 |         break;
 47 |       }
 48 | 
 49 |       case "toTargetHex": {
 50 |         if (!target) { a.state = "idle"; break; }
 51 |         if (approach(a, target.cx, target.cy, 0.06)) {
 52 |           // Visual: colocar spot en el hex (se usa por el render actual)
 53 |           target.eggs ??= { spots: [], born: 0, active: true, fed: 0, tStart: (w as any)._tick ?? 0 };
 54 |           const spots = target.eggs.spots as Array<{ x: number, y: number }>;
 55 | 
 56 |           const idx = target.eggs.born % 6;
 57 |           const ang = Math.PI / 3 * idx + Math.PI / 6;
 58 |           const ring = target.sidePx * 0.78; // interior cerca de aristas
 59 |           const px = target.cx + Math.cos(ang) * ring;
 60 |           const py = target.cy + Math.sin(ang) * ring;
 61 | 
 62 |           spots.push({ x: px, y: py });
 63 |           target.eggs.born++;
 64 | 
 65 |           // Egg entidad pasa a incubar en este hex
 66 |           const eg = eggs.find(e => e.state === "carried" && e.carrierId === a.id);
 67 |           if (eg) {
 68 |             eg.state = "incubating";
 69 |             eg.hexId = target.id; eg.x = px; eg.y = py;
 70 |             eg.fed = eg.fed ?? 0;
 71 |             delete eg.carrierId;
 72 |           }
 73 | 
 74 |           a.carryEgg = false;
 75 |           a.state = "feedEgg";
 76 |         }
 77 |         break;
 78 |       }
 79 | 
 80 |       case "feedEgg": {
 81 |         // alimentar el primer huevo en este hex que aÃºn no alcance EGGS_NEED_UND
 82 |         const eg = eggs.find(e =>
 83 |           e.state === "incubating" &&
 84 |           e.hexId === (target?.id) &&
 85 |           (e.fed ?? 0) < EGGS_NEED_UND);
 86 | 
 87 |         if (!eg) { a.state = "idle"; break; }
 88 | 
 89 |         const need = EGGS_NEED_UND - (eg.fed ?? 0);
 90 |         const take = Math.min(need, CARRY_PER_TRIP, (w as any).stockFood ?? 0);
 91 | 
 92 |         if (take > 0) {
 93 |           (w as any).stockFood = ((w as any).stockFood ?? 0) - take;
 94 |           eg.fed = (eg.fed ?? 0) + take;
 95 |         }
 96 | 
 97 |         if ((eg.fed ?? 0) >= EGGS_NEED_UND) {
 98 |           // huevo listo para eclosiÃ³n (el sistema de crÃ­a decidirÃ¡ el hatch)
 99 |           a.state = "idle";
100 |         }
101 |         break;
102 |       }
103 |     }
104 |   }
105 | }
106 | 
107 | function approach(a: any, tx: number, ty: number, k = 0.06) {
108 |   const dx = tx - a.x, dy = ty - a.y;
109 |   a.vx = (a.vx ?? 0) * 0.9 + dx * k;
110 |   a.vy = (a.vy ?? 0) * 0.9 + dy * k;
111 |   a.x += a.vx; a.y += a.vy;
112 |   return dx * dx + dy * dy < 9;
113 | }
114 | 
115 | function hoverAround(a: any, cx: number, cy: number) {
116 |   const t = (a._t = ((a._t ?? 0) + 0.06));
117 |   const r = 18;
118 |   const tx = cx + Math.cos(t + a.id) * r;
119 |   const ty = cy + Math.sin(t + a.id) * r;
120 |   approach(a, tx, ty, 0.04);
121 | }

--- sistemas\SistemaPeligros.ts  (0.8 KB)
  1 | import type { World, Hex } from "../../tipos";
  2 | 
  3 | export function SistemaPeligros(w:World){
  4 |   const q = w.hexes.find((h:Hex)=>h.host==="queen");
  5 |   const cx = q?.cx ?? 0, cy = q?.cy ?? 0;
  6 |   const R  = (q?.sidePx ?? 40) * 9; // radio de patio simple
  7 | 
  8 |   for (const hz of w.hazards){
  9 |     const anyHz = hz as any;
 10 |     if (anyHz.vx == null){ anyHz.vx = (Math.random()*2-1)*0.6; anyHz.vy = (Math.random()*2-1)*0.6; }
 11 |     anyHz.vx += (Math.random()*2-1)*0.05;
 12 |     anyHz.vy += (Math.random()*2-1)*0.05;
 13 | 
 14 |     hz.x += anyHz.vx; hz.y += anyHz.vy;
 15 | 
 16 |     // Rebotar suave si sale del radio
 17 |     const dx = hz.x - cx, dy = hz.y - cy;
 18 |     const d = Math.hypot(dx,dy) || 1;
 19 |     if (d > R){
 20 |       hz.x = cx + dx*(R/d);
 21 |       hz.y = cy + dy*(R/d);
 22 |       anyHz.vx *= 0.5; anyHz.vy *= 0.5;
 23 |     }
 24 |   }
 25 | }

--- sistemas\SistemaPercepcion.ts  (0.2 KB)
  1 | /** SistemaPercepcion  Lote D: placeholder (no-op). */
  2 | import { World } from "../../tipos";
  3 | export function SistemaPercepcion(_w:World, _dt:number){ /* no-op por ahora */ }

--- sistemas\SistemaPlanificacion.ts  (1.5 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | import { axialToPixelPT } from "../../utilidades/hex";
  4 | 
  5 | const DIRS: Array<[number, number]> = [[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]];
  6 | 
  7 | export function SistemaPlanificacion(w: World, _cfg: Cfg) {
  8 |   const qh = w.hexes.find(h => (h as any).host === "queen");
  9 |   if (!qh) return;
 10 | 
 11 |   // meta segura
 12 |   (w as any).meta ??= {};
 13 |   const m = (w as any).meta;
 14 | 
 15 |   // si ya hay un objetivo, no replantear
 16 |   if (m.buildTargetHexId) return;
 17 | 
 18 |   // huevos "en la reina" (con la cadena correcta)
 19 |   const eggsAtQueen = (w.eggs ?? []).filter(e => e.state === "atQueen").length;
 20 |   if (eggsAtQueen < 6) return;
 21 | 
 22 |   // requiere una constructora viva
 23 |   if (!w.ants.some(a => a.kind === "builder")) return;
 24 | 
 25 |   // buscar vecino libre
 26 |   const S = (qh as any).sidePx;
 27 |   const aq = (qh as any).aq ?? 0;
 28 |   const ar = (qh as any).ar ?? 0;
 29 | 
 30 |   for (let i = 0; i < 12; i++) {
 31 |     const d = DIRS[(Math.random() * 6) | 0];
 32 |     const nq = aq + d[0], nr = ar + d[1];
 33 |     if (w.hexes.some(h => (h as any).aq === nq && (h as any).ar === nr)) continue;
 34 | 
 35 |     const p = axialToPixelPT(nq, nr, S);
 36 |     const hx: any = {
 37 |       id: w.nextHexId++,
 38 |       cx: (qh as any).cx + p.x, cy: (qh as any).cy + p.y,
 39 |       sidePx: S, aq: nq, ar: nr,
 40 |       host: "builder",
 41 |       completed: false,
 42 |       builtUnits: 0,
 43 |       targetUnits: 100, // coste total en unidades de banco
 44 |       eggs: { born: 0, active: false, fed: 0, spots: [] }
 45 |     };
 46 |     w.hexes.push(hx);
 47 |     m.buildTargetHexId = hx.id; // marcar objetivo
 48 |     break;
 49 |   }
 50 | }

--- sistemas\SistemaReina.ts  (1.1 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | // Valores coherentes con lo que venimos usando
  5 | const EGG_COST = 25;         // 25 und por huevo
  6 | const EGG_LAY_PERIOD = 30;   // 1 huevo cada ~30 ticks
  7 | const MAX_EGGS_AT_QUEEN = 6; // tope en la reina
  8 | 
  9 | export function SistemaReina(w:World, _cfg:Cfg){
 10 |   // Garantías de estructura
 11 |   (w as any).eggs = (w as any).eggs ?? [];
 12 |   (w as any).nextEggId = (w as any).nextEggId ?? 1;
 13 |   w.stockFood = w.stockFood ?? 0;
 14 | 
 15 |   const q = w.hexes.find(h => h.host === "queen");
 16 |   const t = (w as any)._tick ?? 0;
 17 |   if (!q) return;
 18 | 
 19 |   // Huevos que orbitan en la reina
 20 |   const atQueen = (w.eggs as any[]).filter(e => e.state === "atQueen").length;
 21 | 
 22 |   // Postura: coste, periodo, y tope
 23 |   if ((t % EGG_LAY_PERIOD) === 0 && atQueen < MAX_EGGS_AT_QUEEN && w.stockFood >= EGG_COST){
 24 |     w.stockFood -= EGG_COST;
 25 | 
 26 |     (w.eggs as any[]).push({
 27 |       id: (w as any).nextEggId++,
 28 |       x: q.cx, y: q.cy,
 29 |       state: "atQueen" as const,
 30 |       carrierId: null,
 31 |       targetHexId: null,
 32 |       fed: 0,
 33 |       tStart: t,
 34 |       hatchTicks: 0,
 35 |     });
 36 |   }
 37 | }

--- sistemas\SistemaScout.ts  (2.8 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | const RND = (n:number)=> (Math.random()*n)-(n/2);
  5 | 
  6 | export function SistemaScout(w:World, _cfg:Cfg){
  7 |   const W:any = w as any;
  8 |   const ants:any[] = w.ants as any[];
  9 | 
 10 |   // radio del domo cacheado
 11 |   if (W._domoR == null){
 12 |     const q = w.hexes.find((h:any)=>h.host==="queen");
 13 |     W._domoR = q ? q.sidePx*6.2 : Math.min((W.width||1200),(W.height||800))*0.35;
 14 |   }
 15 | 
 16 |   // seed: 1 scout + 1 kel (una sola vez)
 17 |   if (!W._scoutSeeded){
 18 |     const q = w.hexes.find((h:any)=>h.host==="queen");
 19 |     const cx = q?.cx ?? (W.width*0.5), cy = q?.cy ?? (W.height*0.5);
 20 |     ants.push({ id:w.nextAntId++, kind:"scout", x:cx+40, y:cy, vx:0, vy:0, state:"scouting" } as any);
 21 |     ants.push({ id:w.nextAntId++, kind:"kel",   x:cx+10, y:cy, vx:0, vy:0, state:"escort" } as any);
 22 |     W._scoutSeeded = true;
 23 |   }
 24 | 
 25 |   const scout = ants.find(a=>a.kind==="scout");
 26 |   const kel   = ants.find(a=>a.kind==="kel");
 27 |   if (!scout || !kel) return;
 28 | 
 29 |   // velocidad con bonificación si están cerca
 30 |   const dPair = Math.hypot(kel.x - scout.x, kel.y - scout.y);
 31 |   const speed = dPair < 24 ? 2.0 : 1.0;
 32 | 
 33 |   // deambular del scout (tendencia a salir del domo)
 34 |   const q = w.hexes.find((h:any)=>h.host==="queen");
 35 |   if (q){
 36 |     const dx = scout.x - q.cx, dy = scout.y - q.cy;
 37 |     const r = Math.hypot(dx,dy);
 38 |     if (r < W._domoR + 30){
 39 |       scout.vx += (dx/(r||1))*0.3 + RND(0.2);
 40 |       scout.vy += (dy/(r||1))*0.3 + RND(0.2);
 41 |     } else {
 42 |       scout.vx += RND(0.3);
 43 |       scout.vy += RND(0.3);
 44 |     }
 45 |   }
 46 |   scout.vx *= 0.96; scout.vy *= 0.96;
 47 |   scout.x  += scout.vx * speed; scout.y += scout.vy * speed;
 48 | 
 49 |   // kel orbita al scout; si está en modo mensajero, va a la reina
 50 |   const messenger = !!(W.meta?.scoutVigilia && (W.meta as any).kelIsMessenger);
 51 |   if (!messenger){
 52 |     const ang = (W._tick||0)*0.05;
 53 |     const R   = 18 * (W.meta?.scoutVigilia ? 3 : 1);
 54 |     const tx = scout.x + Math.cos(ang)*R;
 55 |     const ty = scout.y + Math.sin(ang)*R;
 56 |     kel.x += (tx - kel.x)*0.2;
 57 |     kel.y += (ty - kel.y)*0.2;
 58 |   } else if (q){
 59 |     kel.x += (q.cx - kel.x)*0.08;
 60 |     kel.y += (q.cy - kel.y)*0.08;
 61 |     if (Math.hypot(kel.x-q.cx, kel.y-q.cy) < 18){
 62 |       (W.meta as any).kelIsMessenger = false; // llegó
 63 |     }
 64 |   }
 65 | 
 66 |   // ¿hay comida fuera del domo?
 67 |   const hasOutsideFood = q
 68 |     ? w.food.some((f:any)=> f.amount>0 && Math.hypot(f.x-q.cx,f.y-q.cy) > W._domoR+10)
 69 |     : false;
 70 | 
 71 |   W.meta = W.meta ?? {};
 72 |   if (hasOutsideFood){
 73 |     (W.meta as any).scoutVigilia   = true;
 74 |     (W.meta as any).umbilicalActive= true;
 75 |     (W.meta as any).umbilicalX     = scout.x;
 76 |     (W.meta as any).umbilicalY     = scout.y;
 77 |     (W.meta as any).kelIsMessenger = true; // kel va a avisar
 78 |   } else {
 79 |     (W.meta as any).scoutVigilia   = false;
 80 |     (W.meta as any).umbilicalActive= false;
 81 |   }
 82 | }

--- sistemas\SistemaSemilla.ts  (0.8 KB)
  1 | import type { World } from "../../tipos";
  2 | import type { Cfg } from "../configuracion/predeterminados";
  3 | 
  4 | let seeded = false;
  5 | 
  6 | /** Crea 1 builder, 3 workers y 1 nurse si faltan. Solo una vez por sesión. */
  7 | export function SistemaSemilla(w:World, _cfg:Cfg){
  8 |   if (seeded) return;
  9 |   const q = w.hexes.find(h=> (h as any).host==="queen") as any;
 10 |   if (!q) return;
 11 | 
 12 |   const mk = (kind:"worker"|"builder"|"nurse") => w.ants.push({
 13 |     id: w.nextAntId++,
 14 |     kind,
 15 |     x: q.cx, y: q.cy, vx:0, vy:0,
 16 |     carryingUnits: 0,
 17 |     state: "foraging",
 18 |     homeHexId: q.id,
 19 |   } as any);
 20 | 
 21 |   if (!w.ants.some(a=>a.kind==="builder")) mk("builder");
 22 |   const workers = w.ants.filter(a=>a.kind==="worker").length;
 23 |   for (let i=workers; i<3; i++) mk("worker");
 24 |   if (!w.ants.some(a => (a as any).kind === "nurse")) mk("nurse" as any);
 25 | 
 26 |   seeded = true;
 27 | }
 28 | 


